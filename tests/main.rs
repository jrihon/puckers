
fn main() {

//    use std::f64::consts::PI;
//
//    const TWOPI: f64 = 2. * PI;
//
//    // Rust method
//    let vec4: Vec<f64> = vec![0.,1.,2.,3.,4.,5.].iter()
//                           .map(|j| TWOPI * ((j - 1.) / 3.))
//                           .collect::<Vec<f64>>();
//
//    // Manual method
//    let mut vec5: Vec<f64> = Vec::with_capacity(6);
//
//    // Array method
//    let vec6 : [f64;6] = [0.,1.,2.,3.,4.,5.].map(|j| TWOPI * ((j - 1.) / 3.));
//
//    for j in 0..6  {
//        vec5.push((TWOPI * (j as f64 - 1.)) / 3.)
//    };
//
//
//    println!("{:?}", vec4);
//    println!("{:?}", vec5);
//    println!("{:?}", vec6);
//
//
//
//
//
//
//
//
//    // Rust method
//    let vec1: Vec<f64> = vec![0.,1.,2.,3.,4.,5.].into_iter()
//                           .map(|j| (-1_f64).powf(j))
//                           .collect::<Vec<f64>>();
//                           
//    // Manual method
//    let mut vec2: Vec<f64> = Vec::with_capacity(6);
//    for j in 0..6  {
//        vec2.push(-1_f64.powi(j))
//    }
//
//    let vec3: [f64;6] = [0.,1.,2.,3.,4.,5.].map(|j| -1_f64.powf(j));
//
//
//    println!("{:?}", vec1);
//    println!("{:?}", vec2);
//    println!("{:?}", vec3);

//    let c = [
//        [1., 2., 3.],
//        [4., 5., 6.],
//        [7., 8., 9.],
//    ];
//
//    println!("{:?}", c[1][0]);

}
